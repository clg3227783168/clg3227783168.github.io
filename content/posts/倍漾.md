## 开盘价

[本题需要使用C++语言完成]

假设市场中有若干股票可以交易，这些股票每天的开盘价由集合竞价产生。在本题中，你需要实现一个类`OpenPriceCalculator`，其功能是在集合竞价阶段动态地维护所有股票的开盘价。

### 基本定义

- 整数`t`是股票的唯一标识符
- 每只股票在昨日的收盘价记作$preclose_{t}$，该值对于股票`t`而言是一个给定的常数
- 每只股票在今日的开盘价记作$open_{t}$，该值在集合竞价过程中不断变化
- 在集合竞价阶段，交易者可以向系统报入形如$(o,t,d,p,v)$的订单：
  - `o`是一个整数，是订单的唯一标识符
  - `t`是股票的标识符
  - `d`是交易方向，其值为"B"或"S"，表示买入或卖出
  - `p`是预期价格
  - `v`是预期成交量
- 例如，$(1,123,B,5.0,100)$表示交易者希望以5.0的价格买入100股123号股票，该订单的标识符为1
- 当一个订单被系统验证为合法后，它就会被送入对应股票的订单序列$Q_{t}$，否则会被直接忽略

### 订单的合法性检验

订单$(o,t,d,p,v)$是合法的，当且仅当其同时满足以下两个条件：

1. 报价不超过涨跌停价的范围，即$p \in [0.9 \times preclose_{t}, 1.1 \times preclose_{t}]$
2. 报价最多精确到小数点后两位。例如，5.0，3.95是合法的价格，但1.234不是合法的价格

### 开盘价$open_{t}$的计算方法

- 若$Q_{t}$为空，则$open_{t}$等于$preclose_{t}$
- 否则：
  - 定义集合$\mathbb{P} = \{p \mid (o,t,d,p,v) \in Q_{t}\}$
  - 对于$p \in \mathbb{P}$，定义累计买入量$V_{B}(p)$为$Q_{t}$中所有报价不低于`p`的买单的容量之和
  - 对于$p \in \mathbb{P}$，定义累计卖出量$V_{S}(p)$为$Q_{t}$中所有报价不高于`p`的卖单的容量之和
  - 对于$p \in \mathbb{P}$，定义可成交量$M(p) = \min\left(V_{B}(p), V_{S}(p)\right)$
  - 对于$p \in \mathbb{P}$，定义未成交量$U(p) = \left|V_{B}(p) - V_{S}(p)\right|$
  - $open_{t}$必须是集合$\mathbb{P}$中的值，且它可以使得$M(p)$最大；若同时存在多个价格使得$M(p)$最大，则选择使得$U(p)$最小的价格作为开盘价；若仍然同时存在多个价格使得$U(p)$最小，则选择最高的价格作为开盘价

### OpenPriceCalculator 需要支持的核心方法

- `receive_order`: 收到一条报单$(o,t,d,p,v)$
- `cancel_order`: 撤销标识为`o`的报单
- `query_open`: 查询股票`t`的当前开盘价$open_{t}$
- 你还可以实现一些其他你认为有必要的方法

### 测试流程

1. 首先输入一个整数`T`，表示股票的总数
2. 然后输入`T`个值，依次为$preclose_{1}$，$preclose_{2}$，$\dots$，$preclose_{T}$
4. 后续通过方法调用的形式传入若干个动作，每个动作可以是报单、撤单或查询开盘价

### 数据范围

- $1 \le T \le 1000$
- $1 \le t \le T$，即股票标识符从1开始计数
- $1 \le o$，即订单标识符从1开始计数，数据保证不同订单的`o`不相同
- $0 < preclose_{t} \le 10$，且所有$preclose_{t}$最多精确到小数点后两位

### 优化目标

1. 由于该系统会在集合竞价阶段内"流式地"运行，所以动作调用的次数可能很多，你需要首先优化时间复杂度
2. 在优化时间复杂度的前提下，优化内存占用